int n;
vi e[maxn];

namespace HLD {
int p[maxn], s[maxn], h[maxn], root[maxn];
Rmq rmq[maxn];

void dfs1(int v, int anc) {
    s[v] = 1;
    if (anc != -1) e[v].erase(find(all(e[v]), anc));
    for (int to: e[v]) {
        p[to] = v;
        h[to] = h[v] + 1;
        dfs1(to, v);
        s[v] += s[to];
    }
}

void dfs2(int v, int rt) {
    root[v] = rt;
    if (e[v].empty()) {
        rmq[rt] = Rmq(h[v] - h[rt] + 1);
        return;
    }
    int mxv = e[v][0];
    for (int to: e[v]) {
        if (s[to] > s[mxv]) mxv = to;
    }
    for (int to: e[v]) {
        dfs2(to, to == mxv ? rt : to);
    }
}

int get(int u, int v) {
    int res = 0;
    int t;
    while (root[u] != root[v]) {
        if (h[root[u]] > h[root[v]]) {
            t = rmq[root[u]].get(0, h[u] - h[root[u]] + 1);
            u = p[root[u]];
        } else {
            t = rmq[root[v]].get(0, h[v] - h[root[v]] + 1);
            v = p[root[v]];
        }
        res = max(res, t);
    }
    int r = root[u];
    if (h[u] > h[v]) {
        t = rmq[r].get(h[v] - h[r], h[u] - h[r] + 1);
    } else {
        t = rmq[r].get(h[u] - h[r], h[v] - h[r] + 1);
    }
    return max(res, t);
}

void put(int v, int x) {
    rmq[root[v]].put(h[v] - h[root[v]], x);
}

void init() {
    const int ROOT = 0;
    h[0] = 0;
    dfs1(ROOT, -1);
    dfs2(ROOT, ROOT);
}
} // namespace HLD
